---
name: orchestrator
description: Plan and coordinate multi-agent bead execution. Use when starting a new epic, assigning tracks to agents, or monitoring parallel work progress.
---

# Orchestrator Skill: Autonomous Multi-Agent Coordination

This skill spawns and monitors parallel worker agents that execute beads autonomously.

## Prerequisites

1. **Required**: Run `/skill planning` first to generate `history/<feature>/execution-plan.md`
2. **Recommended**: Run `/skill review-beads` to validate bead quality before spawning workers

## Architecture (Mode B: Autonomous)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              ORCHESTRATOR                                   │
│                              (This Agent)                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Read execution-plan.md (from planning skill)                            │
│  2. Initialize Agent Mail                                                   │
│  3. Spawn worker subagents via Task()                                       │
│  4. Monitor progress via Agent Mail                                         │
│  5. Handle cross-track blockers                                             │
│  6. Announce completion                                                     │
└─────────────────────────────────────────────────────────────────────────────┘
           │
           │ Task() spawns parallel workers
           ▼
┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐
│  BlueLake        │  │  GreenCastle     │  │  RedStone        │
│  Track 1         │  │  Track 2         │  │  Track 3         │
│  [a → b → c]     │  │  [x → y]         │  │  [m → n → o]     │
├──────────────────┤  ├──────────────────┤  ├──────────────────┤
│  For each bead:  │  │  For each bead:  │  │  For each bead:  │
│  • Reserve files │  │  • Reserve files │  │  • Reserve files │
│  • Do work       │  │  • Do work       │  │  • Do work       │
│  • Report mail   │  │  • Report mail   │  │  • Report mail   │
│  • Next bead     │  │  • Next bead     │  │  • Next bead     │
└──────────────────┘  └──────────────────┘  └──────────────────┘
           │                   │                   │
           └───────────────────┼───────────────────┘
                               ▼
                    ┌─────────────────────┐
                    │     Agent Mail      │
                    │  ─────────────────  │
                    │  Epic Thread:       │
                    │  • Progress reports │
                    │  • Bead completions │
                    │  • Blockers         │
                    │                     │
                    │  Track Threads:     │
                    │  • Bead context     │
                    │  • Learnings        │
                    └─────────────────────┘
```

---

## Phase 1: Read Execution Plan

The planning skill outputs `history/<feature>/execution-plan.md` with:

- Track assignments (agent name, beads, file scope)
- Cross-track dependencies
- Key learnings from spikes

```bash
# Read the execution plan
Read("history/<feature>/execution-plan.md")
```

Extract:

- `EPIC_ID` - the epic bead id
- `TRACKS` - array of {agent_name, beads[], file_scope}
- `CROSS_DEPS` - any cross-track dependencies
- `ORCH_NAME` - will be set in Phase 2 (auto-generated by Agent Mail)

---

## Phase 2: Initialize Agent Mail

```bash
macro_start_session(human_key="<absolute-project-path>", program="claude-code", model="<model>", task_description="Orchestrator for <epic-id>")
# ⚠️ Agent Mail enforces adjective+noun names (e.g., "TopazRiver", "GreenCastle").
#   Do NOT pass a custom name — let it auto-generate.
#   Capture the assigned name from the response → use as ORCH_NAME for all subsequent calls.
```

Extract the assigned name from the response:
- `ORCH_NAME` - the auto-generated orchestrator agent name (e.g., "TopazRiver")

---

## Phase 3: Spawn Worker Subagents

**Spawn all workers in parallel** using `Task(subagent_type="worker")` — one per track. Use the Worker Prompt Template below for each spawn. The worker agent (`~/.claude/agents/worker.md`) is auto-loaded via `subagent_type`.

---

## Phase 4: Monitor Progress

While workers execute, monitor via Agent Mail and bead status:

```bash
search_messages(project_key="<path>", query="<epic-id>", limit=20)
fetch_inbox(project_key="<path>", agent_name=ORCH_NAME, urgent_only=true, include_bodies=true)
bv --robot-triage --graph-root <epic-id> 2>/dev/null | jq '.quick_ref'
```

---

## Phase 5: Handle Cross-Track Issues

### If Worker Reports Blocker

```bash
# Read the blocker message
# Determine if it's:
# 1. Waiting on another track → message that worker
# 2. Needs decision → make decision and reply
# 3. External blocker → update bead status

reply_message(
  message_id=<blocker-msg-id>,
  body_md="Resolution: ..."
)
```

### If File Conflict

```bash
# Check who holds reservation
# Message holder to coordinate
send_message(
  to=["<Holder>"],
  thread_id="<epic-id>",
  subject="File conflict resolution",
  body_md="<Worker> needs <files>. Can you release?"
)
```

---

## Phase 5.5: Verify Worker Deliverables

**When a worker reports a bead complete, verify THREE things before accepting:**

### 1. Commit Exists
```bash
git log --all --grep="Bead: <bead-id>" --oneline
# Must return at least one commit
```

### 2. Bead Is Closed
```bash
bd show <bead-id>
# Status must be "done"
```

### 3. Deliverables Reported
Worker message MUST include: commit hash, test counts, bead status. If any field is missing, reject.

### On Failure — Reject and Reassign

```bash
# If commit missing:
send_message(to=["<Worker>"], thread_id="<epic-id>",
  subject="[<bead-id>] REJECTED — no commit found",
  body_md="No commit with `Bead: <bead-id>` found. Commit your work and re-report.",
  importance="high")

# If bead not closed:
send_message(to=["<Worker>"], thread_id="<epic-id>",
  subject="[<bead-id>] REJECTED — bead not closed",
  body_md="Bead <bead-id> status is not 'done'. Run `bd close <bead-id>` and re-report.",
  importance="high")

# If deliverables incomplete:
send_message(to=["<Worker>"], thread_id="<epic-id>",
  subject="[<bead-id>] REJECTED — missing deliverables",
  body_md="Report must include: commit hash, test counts (N/M), bead status. Re-send.",
  importance="high")
```

**Do NOT proceed to Phase 6 until ALL beads pass verification.**

---

## Phase 6: Epic Completion

When all workers report track complete AND all beads verified:

### Verify All Done

```bash
bv --robot-triage --graph-root <epic-id> 2>/dev/null | jq '.quick_ref.open_count'
# Should be 0
```

### Send Completion Summary

```bash
send_message(
  to=["BlueLake", "GreenCastle", "RedStone"],
  thread_id="<epic-id>",
  subject="[<epic-id>] EPIC COMPLETE",
  body_md="""
## Epic Complete: <title>

### Track Summaries
- Track 1 (BlueLake): <summary>
- Track 2 (GreenCastle): <summary>
- Track 3 (RedStone): <summary>

### Deliverables
- <what was built>

### Learnings
- <key insights>
"""
)
```

### Save Summary to History

Write the same summary to `history/<feature>/summary.md` so it persists beyond Agent Mail:

```bash
Write("history/<feature>/summary.md", """
# Epic Complete: <title>

**Epic:** <epic-id>
**Date:** <completion-date>

## Track Summaries
- Track 1 (<AgentName>): <summary>
- Track 2 (<AgentName>): <summary>
- Track 3 (<AgentName>): <summary>

## Deliverables
- <what was built>

## Learnings
- <key insights>
""")
```

### Close Epic

```bash
bd close <epic-id> --reason "All tracks complete"
```

---

## Worker Prompt Template

Use this template when spawning workers with `subagent_type="worker"`:

```
You are agent {AGENT_NAME} working on Track {N} of epic {EPIC_ID}.

## Setup
Read {PROJECT_PATH}/AGENTS.md for tool preferences.

## Your Assignment
- Orchestrator: {ORCH_NAME}
- Beads (in order): {BEAD_LIST}
- File scope: {FILE_SCOPE}
- Epic thread: {EPIC_ID}
- Track thread: track:{AGENT_NAME}:{EPIC_ID}

## Deliverables Contract
For EACH bead, your completion report MUST include:
1. **Commit hash** — from `git log -1 --format='%h'`
2. **Test counts** — N passed / M total
3. **Bead status** — confirmed "done" via `bd show`

Orchestrator VERIFIES these before accepting completion.
Missing any field = rejection and rework.

Follow the worker workflow for each bead.
Return a summary of all work completed.
```

**Note:** The worker agent definition (`~/.claude/agents/worker.md`) is automatically loaded via `subagent_type="worker"`. No explicit Read() needed.

---

## Red Flags - STOP

- Never accept unverified work — self-reports are not proof
- Worker says "done" → verify commit exists via `git log --grep`
- Bead "closed" → confirm with `bd show`, don't trust reports alone
- Proceeding to Phase 6 → ALL Phase 5.5 verifications must pass first
- Missing deliverables (no hash, no test counts) → reject immediately

---

## Quick Reference

| Phase      | Action                                        |
| ---------- | --------------------------------------------- |
| Read Plan  | `Read("history/<feature>/execution-plan.md")` |
| Initialize | `ensure_project`, `register_agent`            |
| Spawn      | `Task()` for each track (parallel)            |
| Monitor    | `fetch_inbox`, `search_messages`              |
| Resolve    | `reply_message` for blockers                  |
| **Verify** | `git log --grep`, `bd show`, check report     |
| Complete   | All verified, send summary, close epic        |